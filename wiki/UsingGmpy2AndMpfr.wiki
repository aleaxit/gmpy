#summary Using gmpy2 and mpfr.

*Note: These instructions assume source revision r509 or later is used. They do NOT apply to the 2.0.0a1 source release.*

=Using gmpy2 and mpfr=

==Overview==

MPFR is a library that provides correctly rounding multiple precision floating-point aithmetic. In addition to supporting the basic arithmetic operations, MPFR support a wide variety of both elementary and advanced functions. The precision and exponent range can be changed to suit the needs of a particular calculation.

==Examples==

Some trivial examples.

{{{
>>> import gmpy2
>>> gmpy2.mpfr(1.2)
mpfr('1.2e0')
>>> gmpy2.sqrt(gmpy2.mpfr(3.2))
mpfr('1.7888543819998317e0')
>>> gmpy2.sin(gmpy2.mpfr(.5))
mpfr('4.7942553860420301e-1')
>>> 
}}}

*gmpy2* uses a context manager to control the precision and exponent range, rounding mode, track the occurance of any "exceptions", and to optionally raise a Python exception. 

{{{
>>> gmpy2.context()
context(subnormalize=False,
        precision=53,
        round=RoundToNearest,
        emax=1073741823, emin=-1073741823,
        trap_underflow=False, underflow=False,
        trap_overflow=False, overflow=False,
        trap_inexact=False, inexact=True,
        trap_invalid=False, invalid=False,
        trap_erange=False, erange=False,
        trap_divzero=False, divzero=False)
>>> gmpy2.context().precision = 100
>>> gmpy2.sqrt(gmpy2.mpfr(3.2))
mpfr('1.7888543819998318067780219999297e0',100)
>>> gmpy2.context()
context(subnormalize=False,
        precision=100,
        round=RoundToNearest,
        emax=1073741823, emin=-1073741823,
        trap_underflow=False, underflow=False,
        trap_overflow=False, overflow=False,
        trap_inexact=False, inexact=True,
        trap_invalid=False, invalid=False,
        trap_erange=False, erange=False,
        trap_divzero=False, divzero=False)
>>>
}}}

In the previous example, the precision was increased to 100 bits and then the sqrt(3.2) was calculated. Since sqrt(3.2) can not be calculated exactly, the inexact flag is set. The flags accumulate all the exceptional conditions that occur during a sequence of calculations. To clear all the flags, use `gmpy2.context().clear_flags()`. To clear an individual flag, use `gmpy2.context().underflow = False`.

When exceptional conditions are encountered, MPFR returns "nan", "inf", or "-inf" and sets the appropriate exception flag. This is the default behavior in *gmpy2*. Exceptions can be enabled by setting the corresponding trap attribute of the context.

{{{
>>> gmpy2.context()
context(subnormalize=False,
        precision=100,
        round=RoundToNearest,
        emax=1073741823, emin=-1073741823,
        trap_underflow=False, underflow=False,
        trap_overflow=False, overflow=False,
        trap_inexact=False, inexact=False,
        trap_invalid=False, invalid=False,
        trap_erange=False, erange=False,
        trap_divzero=False, divzero=False)
>>> 1/gmpy2.mpfr(0)
mpfr('inf')
>>> gmpy2.context()
context(subnormalize=False,
        precision=100,
        round=RoundToNearest,
        emax=1073741823, emin=-1073741823,
        trap_underflow=False, underflow=False,
        trap_overflow=False, overflow=False,
        trap_inexact=False, inexact=False,
        trap_invalid=False, invalid=False,
        trap_erange=False, erange=False,
        trap_divzero=False, divzero=True)
>>> gmpy2.context().trap_divzero = True
>>> 1/gmpy2.mpfr(0)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
gmpy2.DivisionByZeroError: 'mpfr' division by zero
>>> 
}}}

By setting `context().trap_erange = True`, comparisons involving "nan" will generate an exception.

{{{
>>> gmpy2.context().trap_erange = True
>>> gmpy2.mpfr('nan') == gmpy2.mpfr('nan')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
gmpy2.RangeError: comparison with NaN
}}}

`context()` always refers to the current context. A new context object can be created with `new_context()`. To activate a context object, use `set_context(new_context())`. The "with ..." statement can also be used.

{{{
>>> with context() as ctxt:
...     for i in range(4):
...         ctxt.precision += 10
...         print(gmpy2.mpfr(gmpy2.sqrt(2.0)))
... 
1.4142135623730950488
1.4142135623730950488017
1.4142135623730950488016887
1.4142135623730950488016887241
>>> 
}}}

